{"meta":{"title":"曲达的博客","subtitle":"Stay hungry. Stay foolish.","description":"沉下去，记录点滴，每天进步一点点。涉猎JS、CSS、HTML、VUE、REACT、RN。","author":"曲达","url":"http://quda.me"},"pages":[{"title":"about","date":"2017-02-07T08:25:48.000Z","updated":"2017-02-07T08:25:48.000Z","comments":true,"path":"about/index.html","permalink":"http://quda.me/about/index.html","excerpt":"","text":""},{"title":"","date":"2017-02-07T08:26:01.000Z","updated":"2017-02-07T11:05:50.000Z","comments":true,"path":"categories/index.html","permalink":"http://quda.me/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-02-07T08:25:54.000Z","updated":"2017-02-07T08:32:34.000Z","comments":false,"path":"tags/index.html","permalink":"http://quda.me/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JS-Promise","slug":"js-Promise","date":"2017-02-10T11:42:58.000Z","updated":"2017-02-10T11:44:52.000Z","comments":true,"path":"2017/02/10/js-Promise/","link":"","permalink":"http://quda.me/2017/02/10/js-Promise/","excerpt":"","text":"promise是什么 Talk is cheap,show me the code. 先上一段经典的promise使用代码12345678910111213141516const promise = new Promise(function(resolve, reject)&#123; //do some async ... if (success) &#123; resolve() &#125; else &#123; reject() &#125; ...&#125;)promise.then((value) =&gt; &#123; //do success things&#125;,(error) =&gt; &#123; //do error things&#125;) promise 就是一种以同步方式来解决异步回调地狱问题的解决方案。一个Promise对象代表的是一个异步操作（当然你也可以操作一个同步操作，但是promise的内部实现保证这样的结果依然是异步执行的），它有三种状态：Pending(进行中)、Resolved(已完成)、Rejected(已失败)，三种状态的关系如下图： 可以看出，一个promise执行时状态不可逆的，一旦开始执行，结果有且只有两种可能： 初始化 =&gt; 成功 执行resolve() 初始化 =&gt; 失败 执行reject() 状态转换后，这个promise对象的状态就不会再发生任何的变化，换言之.then方法内的方法只会被调用一次 创建一个promise const propmiseFn = new Promise (fn) const propmiseFn = Promise.resolve(value) const propmiseFn = Promise.reject(value) 后两种方法相当于 new Promise() 的快捷方式，拿第二种方法举例，比如Promise.resolve(&#39;some resul&#39;) 可以认为是以下代码的语法糖123new Promise(function(resolve)&#123; resolve(&apos;some resul&apos;);&#125;); resolve(&#39;some resul&#39;)会让这个promise对象立即进入resolved状态，并将some result传递给后面then里指定的onFulfilled函数 基本APIPromises/A+ 标准实际上只是定义了关于Promise#then的规范，这里讨论的是ES6 Promise标准，它在Promises/A+的基础上又扩展了一些方法，具体如下： Promise.reolve() Promise.reject() Promises.prototype.then() Promises.prototype.catch() 123promise.catch(onRejected) //等价于promise.then(null, onRejected) Promises.all() 1234567891011const p1 = Promise.resolve(1)const p2 = Promise.resolve(2)const p3 = Promise.resolve(3) //接受一个由promise对象组成的数组const p = Promise.all([p1, p2, p3]) p.then((value) =&gt; &#123; //直到所有的异步操作全部完成后才返回结果，结果是一个相同顺序的数组 console.log(value) // =&gt; [1, 2, 3]&#125;) Promise.race() 123456789101112//接受一个promise对象数组，执行.then()后返回最先完成的那一个promise的结果const p1 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 500, &quot;one&quot;); &#125;);const p2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, 100, &quot;two&quot;); &#125;);Promise.race([p1, p2]).then((value) =&gt; &#123; console.log(value); // =&gt; &quot;two&quot; // Both resolve, but p2 is faster&#125;); ## 4、promise chain 在平时实践中，我们会经常用到一种调用方式，那就是`promise chain`, **链式调用promise实例**。 先来看一段代码： 12345678910111213141516const promise = new Promisefunction(resolve, reject) =&gt; &#123; resolve(&quot;传递给then的值&quot;);&#125;);&lt;!--实现方式1--&gt;promise.then((value) =&gt; &#123; console.log(value);&#125;,(error) =&gt; &#123; console.error(error);&#125;);&lt;!--实现方式2--&gt;promise.thenfunction (value) =&gt; &#123; console.log(value);&#125;).catch((error) =&gt; &#123; console.error(error);&#125;); 上面的代码展示了一种使用的技巧，**在.catch()方法内部处理异步的异常情况**，需要注意的是使用`promise.then(onFulfilled, onRejected) `的话在`onFulfilled`中发生异常的话，在 `onRejected` 中是捕获不到这个异常的。在 `promise.then(onFulfilled).catch(onRejected) `的情况下`then` 中产生的异常能在 `.catch` 中捕获，在不同的场合下合理的搭配可以使逻辑更加清晰，代码更利于阅读。 那究竟是什么原理可以支持promise这样去使用呢？ 其实关键在于，**不论是.then 还是 .catch 方法执行结束后，会返回一个新的带着当前状态的promise对象**,这样就保证了我们的链式调用，上面的代码的执行过程可以用下图描述： ![image](http://p1.bqimg.com/567571/98e76bd85007b746.png) 我们接着这个思路再往下走，在日常的开发中我们会经常碰到一个场景，将一个函数的处理结果传递给下一个函数进行再处理（其中涉及一条js的最佳实践：保证每一个函数的功能是单一的），那我们可不可以借助`promise chain`来实现呢？ 看下面的代码： 12345678910const bPromise = new Promise((resolve) =&gt; &#123; resolve(100);&#125;);bPromise.then((value) =&gt; &#123; return value * 2;&#125;).then((value) =&gt; &#123; return value * 2;&#125;).then((value) =&gt; &#123; console.log(&quot;value: &quot; + value); // =&gt; 100 * 2 * 2&#125;); 是的，我们只需要在`then()`内部将需要传递下去的数据**return**出去，这样就可以在下一处`then() 或者 catch()`中接收到并继续处理了！ [JavaScript Promise迷你书（中文版）](http://liubin.org/promises-book/#chapter4-advanced-promise) [Javascript 中的神器——Promise ](http://www.jianshu.com/p/063f7e490e9a)","categories":[],"tags":[]},{"title":"call与apply的区别","slug":"The-difference-between-the-call-and-apply","date":"2017-02-07T03:57:06.000Z","updated":"2017-02-07T04:00:05.000Z","comments":true,"path":"2017/02/07/The-difference-between-the-call-and-apply/","link":"","permalink":"http://quda.me/2017/02/07/The-difference-between-the-call-and-apply/","excerpt":"","text":"call 和 apply 都是为了改变某个函数运行时的 context 即上下文而存在的，换句话说，就是为了改变函数体内部 this 的指向。因为 JavaScript 的函数存在「定义时上下文」和「运行时上下文」以及「上下文是可以改变的」这样的概念。 二者的作用完全一样，只是接受参数的方式不太一样。例如，有一个函数 func1 定义如下： var func1 = function(arg1, arg2) {}; 就可以通过 func1.call(this, arg1, arg2); 或者 func1.apply(this, [arg1, arg2]); 来调用。其中 this 是你想指定的上下文，他可以任何一个 JavaScript 对象(JavaScript 中一切皆对象)，call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。 JavaScript 中，某个函数的参数数量是不固定的，因此要说适用条件的话，当你的参数是明确知道数量时，用 call，而不确定的时候，用 apply，然后把参数 push 进数组传递进去。当参数数量不确定时，函数内部也可以通过 arguments 这个数组来便利所有的参数。 123456789101112131415161718192021222324252627282930313233function cat()&#123;&#125;cat.prototype=&#123; food:\"fish\", say: function()&#123; alert(\"I love \"+this.food); &#125;, name: function( name )&#123; console.log('my name is ' + name) &#125;&#125;var blackCat = new cat;blackCat.say();blackCat.name('miaomiao')var whiteDog = &#123; food:\"bone\", say: function()&#123; blackCat.say.call(this) &#125;, name: function( name )&#123; blackCat.name.call(this, name) //blackCat.name.apply(this, [name]) &#125;&#125;whiteDog.say() //bonewhiteDog.name('wangwang')//wangwang//whiteDog中不需要重新定义say方法，直接调用即可","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://quda.me/tags/js/"},{"name":"learn","slug":"learn","permalink":"http://quda.me/tags/learn/"}]}]}